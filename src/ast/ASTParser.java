/* Generated By:JavaCC: Do not edit this line. ASTParser.java */
package ast;
import java.util.*;

/**
	@author GAO RISHENG A0101891L
	this class is in charge of translation between all structural command generated
	from the upper layer of this software to respective ASTNodes
	All the grammar rules are defined in this JavaCC class
	Currently only support C-language AST nodes translation
	Future development is to establish a full support to Java and Python
	line 59 - 319 are defined special tokens
	line 320 - 1464 are defined grammar rules for structural commands and how the compiler construct
	respective AST nodes in parsing respective structural commands 
*/
public class ASTParser implements ASTParserConstants {
  private static ASTNode current = new ASTNode();

  private static ASTNode program = new ASTNode();

  public static void main(String args []) throws ParseException
  {
    ASTParser parser = new ASTParser(System.in);
    //while (true)
    //{
      //.out.println("Reading from standard input...");
      //System.out.print("Enter an program:\u005cn");
      try
      {
        program();
        //System.out.println("AST construction complete.");
      }
      catch (Exception e)
      {
        System.out.println("Not Supported Syntax Format");
        System.out.println(e.getMessage());
        ASTParser.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Unknown Error Occurs.");
        System.out.println(e.getMessage());
        //break;
      }
    //}
  }

  private static void getStructure(ASTNode current)
  {
    Stack < ASTNode > stack = new Stack < ASTNode > ();
    ASTNode temp = current;
    stack.push(temp);
    while (temp.parent != null)
    {
      if (temp.isAblock())
      {
        stack.push(temp);
      }
      temp = temp.getParent();
    }
    int counter = 0;
    while (!stack.isEmpty())
    {
      String indent = "";
      for (int i = 0; i < counter; i++)
      {
        indent += "\u005ct";
      }
      //System.out.println(indent + stack.pop().typeof());
      counter++;
    }
  }

  private static void getTree(ASTNode current)
  {
    ASTNode temp = current;
    while (temp.parent != null)
    {
      temp = temp.getParent();
    }
    System.out.println(temp.toTree(0));
  }

  static final public String variable() throws ParseException {
  Token var;
    jj_consume_token(VARIABLE);
    var = jj_consume_token(IDENTIFIER);
    {if (true) return var.image;}
    throw new Error("Missing return statement in function");
  }

  static final public String infixOperators() throws ParseException {
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      n = jj_consume_token(PLUS);
    {if (true) return n.image;}
      break;
    case MINUS:
      n = jj_consume_token(MINUS);
    {if (true) return n.image;}
      break;
    case STAR:
      n = jj_consume_token(STAR);
    {if (true) return n.image;}
      break;
    case SLASH:
      n = jj_consume_token(SLASH);
    {if (true) return n.image;}
      break;
    case LT:
      n = jj_consume_token(LT);
    {if (true) return n.image;}
      break;
    case GT:
      n = jj_consume_token(GT);
    {if (true) return n.image;}
      break;
    case EQ:
      n = jj_consume_token(EQ);
    {if (true) return n.image;}
      break;
    case LE:
      n = jj_consume_token(LE);
    {if (true) return n.image;}
      break;
    case GE:
      n = jj_consume_token(GE);
    {if (true) return n.image;}
      break;
    case NE:
      n = jj_consume_token(NE);
    {if (true) return n.image;}
      break;
    case SC_OR:
      n = jj_consume_token(SC_OR);
    {if (true) return n.image;}
      break;
    case SC_AND:
      n = jj_consume_token(SC_AND);
    {if (true) return n.image;}
      break;
    case BIT_AND:
      n = jj_consume_token(BIT_AND);
    {if (true) return n.image;}
      break;
    case BIT_OR:
      n = jj_consume_token(BIT_OR);
    {if (true) return n.image;}
      break;
    case XOR:
      n = jj_consume_token(XOR);
    {if (true) return n.image;}
      break;
    case REM:
      n = jj_consume_token(REM);
    {if (true) return n.image;}
      break;
    case SHIFT_LEFT:
      n = jj_consume_token(SHIFT_LEFT);
    {if (true) return n.image;}
      break;
    case SHIFT_RIGHT:
      n = jj_consume_token(SHIFT_RIGHT);
    {if (true) return n.image;}
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String compoundOperators() throws ParseException {
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUSASSIGN:
      n = jj_consume_token(PLUSASSIGN);
    {if (true) return n.image;}
      break;
    case MINUSASSIGN:
      n = jj_consume_token(MINUSASSIGN);
    {if (true) return n.image;}
      break;
    case STARASSIGN:
      n = jj_consume_token(STARASSIGN);
    {if (true) return n.image;}
      break;
    case SLASHASSIGN:
      n = jj_consume_token(SLASHASSIGN);
    {if (true) return n.image;}
      break;
    case REMASSIGN:
      n = jj_consume_token(REMASSIGN);
    {if (true) return n.image;}
      break;
    case ORASSIGN:
      n = jj_consume_token(ORASSIGN);
    {if (true) return n.image;}
      break;
    case ANDASSIGN:
      n = jj_consume_token(ANDASSIGN);
    {if (true) return n.image;}
      break;
    case XORASSIGN:
      n = jj_consume_token(XORASSIGN);
    {if (true) return n.image;}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String prefixOperators() throws ParseException {
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
      n = jj_consume_token(INCR);
    {if (true) return n.image;}
      break;
    case DECR:
      n = jj_consume_token(DECR);
    {if (true) return n.image;}
      break;
    case BANG:
      n = jj_consume_token(BANG);
    {if (true) return n.image;}
      break;
    case TILDE:
      n = jj_consume_token(TILDE);
    {if (true) return n.image;}
      break;
    case BIT_AND:
      n = jj_consume_token(BIT_AND);
    {if (true) return n.image;}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String postfixOperators() throws ParseException {
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCR:
      n = jj_consume_token(INCR);
    {if (true) return n.image;}
      break;
    case DECR:
      n = jj_consume_token(DECR);
    {if (true) return n.image;}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String catchModifier() throws ParseException {
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
      n = jj_consume_token(ABSTRACT);
    {if (true) return n.image;}
      break;
    case PRIVATE:
      n = jj_consume_token(PRIVATE);
    {if (true) return n.image;}
      break;
    case PROTECTED:
      n = jj_consume_token(PROTECTED);
    {if (true) return n.image;}
      break;
    case PUBLIC:
      n = jj_consume_token(PUBLIC);
    {if (true) return n.image;}
      break;
    case STATIC:
      n = jj_consume_token(STATIC);
    {if (true) return n.image;}
      break;
    case FINAL:
      n = jj_consume_token(FINAL);
    {if (true) return n.image;}
      break;
    case SYNCHRONIZED:
      n = jj_consume_token(SYNCHRONIZED);
    {if (true) return n.image;}
      break;
    case VOLATILE:
      n = jj_consume_token(VOLATILE);
    {if (true) return n.image;}
      break;
    case CONST:
      n = jj_consume_token(CONST);
    {if (true) return n.image;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpressionUnitLiteral value() throws ParseException {
  Token n;
  Token sign;
  ASTExpressionUnitLiteral valueNode;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      n = jj_consume_token(INTEGER_LITERAL);
    valueNode = new ASTExpressionUnitLiteral(n.image);
    //System.out.println(valueNode.print());
    {if (true) return valueNode;}
      break;
    case FLOATING_POINT_LITERAL:
      n = jj_consume_token(FLOATING_POINT_LITERAL);
    valueNode = new ASTExpressionUnitLiteral(n.image);
    //System.out.println(valueNode.print());
    {if (true) return valueNode;}
      break;
    case CHARACTER_LITERAL:
      n = jj_consume_token(CHARACTER_LITERAL);
    valueNode = new ASTExpressionUnitLiteral(n.image);
    //System.out.println(valueNode.print());
    {if (true) return valueNode;}
      break;
    case STRING_LITERAL:
      n = jj_consume_token(STRING_LITERAL);
    valueNode = new ASTExpressionUnitLiteral(n.image);
    {if (true) return valueNode;}
      break;
    case TRUE:
      n = jj_consume_token(TRUE);
    valueNode = new ASTExpressionUnitLiteral(n.image);
    {if (true) return valueNode;}
      break;
    case FALSE:
      n = jj_consume_token(FALSE);
    valueNode = new ASTExpressionUnitLiteral(n.image);
    {if (true) return valueNode;}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String primitive_typesJ() throws ParseException {
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BYTE:
      n = jj_consume_token(BYTE);
      {if (true) return n.image;}
      break;
    case INT:
      n = jj_consume_token(INT);
      {if (true) return n.image;}
      break;
    case CHAR:
      n = jj_consume_token(CHAR);
      {if (true) return n.image;}
      break;
    case DOUBLE:
      n = jj_consume_token(DOUBLE);
      {if (true) return n.image;}
      break;
    case FLOAT:
      n = jj_consume_token(FLOAT);
      {if (true) return n.image;}
      break;
    case BOOLEAN:
      n = jj_consume_token(BOOLEAN);
      {if (true) return n.image;}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String primitive_typesC() throws ParseException {
  Token n;
  Token second;
  Token third;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      n = jj_consume_token(INT);
      {if (true) return n.image;}
      break;
    case CHAR:
      n = jj_consume_token(CHAR);
      {if (true) return n.image;}
      break;
    case LONG:
      n = jj_consume_token(LONG);
      {if (true) return n.image;}
      break;
    case SHORT:
      n = jj_consume_token(SHORT);
      {if (true) return n.image;}
      break;
    case DOUBLE:
      n = jj_consume_token(DOUBLE);
      {if (true) return n.image;}
      break;
    case FLOAT:
      n = jj_consume_token(FLOAT);
      {if (true) return n.image;}
      break;
    case C_TYPES_MODIFIERS_SIGNED:
      n = jj_consume_token(C_TYPES_MODIFIERS_SIGNED);
      {if (true) return n.image;}
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String types_C() throws ParseException {
  String token;
  String result = "";
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRUCT:
    case IDENTIFIER:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRUCT:
        jj_consume_token(STRUCT);
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
      n = jj_consume_token(IDENTIFIER);
    {if (true) return n.image;}
      break;
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case C_TYPES_MODIFIERS_SIGNED:
      label_1:
      while (true) {
        token = primitive_typesC();
      result += token + " ";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case C_TYPES_MODIFIERS_SIGNED:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_1;
        }
      }
    {if (true) return result;}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String typesJ() throws ParseException {
  String type;
  Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n = jj_consume_token(IDENTIFIER);
    {if (true) return n.image;}
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
      type = primitive_typesJ();
    {if (true) return type;}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTDeclarationStatementC create_variableC() throws ParseException {
  String type_token;
  Token name;
  String id;
  ASTDeclarationStatementC result;
  ASTExpressionUnitIdentifier var;
  ASTExpression exp = new ASTExpression();
  String temp;
  ArrayList < String > modifiers = new ArrayList < String > ();
    jj_consume_token(CREATE);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case CONST:
      case FINAL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case SYNCHRONIZED:
      case VOLATILE:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_2;
      }
      temp = catchModifier();
      modifiers.add(temp);
    }
    type_token = types_C();
    result = new ASTDeclarationStatementC(type_token);
    for (String s : modifiers)
    {
      result.addModifier(s);
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
        id = variable();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
        case LBRACE:
        case BANG:
        case TILDE:
        case INCR:
        case DECR:
        case MINUS:
        case BIT_AND:
        case ASSIGNMENT:
        case VARIABLE:
        case VALUE:
        case FUNCTION:
        case POST:
        case ARRAY:
        case ACCESS:
          exp = expressionC();
          break;
        default:
          jj_la1[13] = jj_gen;
          ;
        }
        jj_consume_token(DECLARE_END);
        if (exp == null)
        {
          result.addVariableWithoutDeclaration(new ASTExpressionUnitIdentifier(id));
        }
        else
        {
          result.addVariableWithDeclaration(new ASTExpressionUnitIdentifier(id), exp);
          exp = null;
        }
        break;
      case ARRAY:
        jj_consume_token(ARRAY);
        jj_consume_token(VARIABLE);
        name = jj_consume_token(IDENTIFIER);
        ASTExpressionUnitIdentifierArrayObject array = new ASTExpressionUnitIdentifierArrayObject(name.image);
        label_4:
        while (true) {
          jj_consume_token(INDEX);
          exp = expressionC();
          jj_consume_token(INDEX_END);
          array.addIndex(exp);
          result.addVariableWithoutDeclaration(array);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INDEX:
            ;
            break;
          default:
            jj_la1[14] = jj_gen;
            break label_4;
          }
        }
        jj_consume_token(DECLARE_END);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VARIABLE:
      case ARRAY:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_3;
      }
    }
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression fragmentC() throws ParseException {
  Token var = new Token();
  String id;
  Token check = new Token();
  ASTExpressionUnitLiteral v = new ASTExpressionUnitLiteral();
  ASTExpression parameters = new ASTExpression();
  ASTExpression result = new ASTExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VALUE:
      jj_consume_token(VALUE);
      v = value();
    //System.out.println(v.toSyntax());
    {if (true) return v;}
      break;
    case VARIABLE:
      id = variable();
    {if (true) return new ASTExpressionUnitIdentifier(id);}
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
      var = jj_consume_token(IDENTIFIER);
      ASTExpressionUnitFunctionCall call = new ASTExpressionUnitFunctionCall(var.image);
      //System.out.println(var.image);

      jj_consume_token(LPAREN);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PARAMETER:
          ;
          break;
        default:
          jj_la1[17] = jj_gen;
          break label_5;
        }
        jj_consume_token(PARAMETER);
        parameters = expressionC();
        call.addParameter(parameters);
      }
      jj_consume_token(RPAREN);
    {if (true) return call;}
      break;
    case LPAREN:
      check = jj_consume_token(LPAREN);
      result = expressionC();
      jj_consume_token(RPAREN);
    result.quote();
    {if (true) return result;}
      break;
    case LBRACE:
      jj_consume_token(LBRACE);
    ASTExpressionUnitLiteralArray arr = new ASTExpressionUnitLiteralArray();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PARAMETER:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_6;
        }
        jj_consume_token(PARAMETER);
        parameters = expressionC();
      }
    arr.addValue(parameters);
    {if (true) return arr;}
      jj_consume_token(RBRACE);
      break;
    case ARRAY:
      jj_consume_token(ARRAY);
      var = jj_consume_token(IDENTIFIER);
    ASTExpressionUnitIdentifierArrayObject array = new ASTExpressionUnitIdentifierArrayObject(var.image);
      label_7:
      while (true) {
        jj_consume_token(INDEX);
        parameters = expressionC();
        jj_consume_token(INDEX_END);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INDEX:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_7;
        }
      }
    array.addIndex(parameters);
    {if (true) return array;}
      break;
    case ACCESS:
      jj_consume_token(ACCESS);
      var = jj_consume_token(IDENTIFIER);
    ArrayList < String > ids = new ArrayList < String > ();
    ids.add(var.image);
      label_8:
      while (true) {
        var = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_8;
        }
      }
    ids.add(var.image);
      jj_consume_token(ACCESS_END);
    {if (true) return ASTExpressionUnitAccess.generateNestedAccess(ids);}
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression termC() throws ParseException {
  ArrayList < String > operators = new ArrayList < String > ();
  ArrayList < ASTExpression > operands = new ArrayList < ASTExpression > ();
  String operator = null;
  ASTExpression operand1;
  ASTExpression operand2 = new ASTExpression();
  ASTExpression result;
    operand1 = fragmentC();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
      case GT:
      case EQ:
      case LE:
      case GE:
      case NE:
      case SC_OR:
      case SC_AND:
      case PLUS:
      case MINUS:
      case STAR:
      case SLASH:
      case BIT_AND:
      case BIT_OR:
      case XOR:
      case REM:
      case SHIFT_LEFT:
      case SHIFT_RIGHT:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_9;
      }
      operator = infixOperators();
      operators.add(operator);
      operand2 = fragmentC();
      operands.add(operand2);
    }
    if (operator == null || operators.isEmpty())
    {
      result = operand1;
      {if (true) return result;}
    }
    result = new ASTExpression();
    while (!operators.isEmpty())
    {
      result = new ASTExpressionInfixOperation(operators.remove(0), operand1, operands.remove(0));
      operand1 = result;
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression infix_expressionC() throws ParseException {
  ASTExpression result;
    result = termC();
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression prefix_expressionC() throws ParseException {
  String operator;
  Token op;
  ASTExpressionUnitLiteral v;
  ASTExpressionPrefixOperation result;
  ASTExpression exp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case BIT_AND:
      operator = prefixOperators();
      exp = fragmentC();
    result = new ASTExpressionPrefixOperation(operator, exp);
    {if (true) return result;}
      break;
    case MINUS:
      op = jj_consume_token(MINUS);
      exp = expressionC();
    result = new ASTExpressionPrefixOperation(op.image, exp);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression postfix_expressionC() throws ParseException {
  String operator;
  Token var;
    jj_consume_token(POST);
    jj_consume_token(VARIABLE);
    var = jj_consume_token(IDENTIFIER);
    operator = postfixOperators();
    ASTExpressionUnitIdentifier i = new ASTExpressionUnitIdentifier(var.image);
    ASTExpressionPostfixOperation result = new ASTExpressionPostfixOperation(operator, i);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression expressionC() throws ParseException {
  ASTExpression result1;
  ASTExpression result2;
  ASTExpression result3;
  ASTExpression result4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case MINUS:
    case BIT_AND:
    case VARIABLE:
    case VALUE:
    case FUNCTION:
    case POST:
    case ARRAY:
    case ACCESS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case MINUS:
      case BIT_AND:
        result1 = prefix_expressionC();
      {if (true) return result1;}
        break;
      case LPAREN:
      case LBRACE:
      case VARIABLE:
      case VALUE:
      case FUNCTION:
      case ARRAY:
      case ACCESS:
        result2 = infix_expressionC();
      {if (true) return result2;}
        break;
      case POST:
        result3 = postfix_expressionC();
      {if (true) return result3;}
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case ASSIGNMENT:
      result4 = assignmentC();
    {if (true) return result4;}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTExpression assignmentC() throws ParseException {
  ASTExpression term;
  Token operator;
  ASTExpression exp;
  String op;
    jj_consume_token(ASSIGNMENT);
    term = fragmentC();

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WITH:
      token = jj_consume_token(WITH);
      op = " = ";
      break;
    case PLUSASSIGN:
    case MINUSASSIGN:
    case STARASSIGN:
    case SLASHASSIGN:
    case ANDASSIGN:
    case ORASSIGN:
    case XORASSIGN:
    case REMASSIGN:
      op = compoundOperators();
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    exp = expressionC();
    ASTExpressionAssignment result = new ASTExpressionAssignment(term, exp, op);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

/*Block Statement*/
  static final public ASTStructDeclaration structDeclareStatement(ASTNode parent) throws ParseException {
  Token name;
  ASTDeclarationStatementC attribute;
    jj_consume_token(STRUCT_DEC);
    name = jj_consume_token(IDENTIFIER);
    ASTStructDeclaration result = new ASTStructDeclaration(name.image);
    result.addParent(parent);
    jj_consume_token(STRUCT_START);
    label_10:
    while (true) {
      attribute = create_variableC();
      result.addAttribute(attribute);
      //System.out.println(attribute.toSyntax());
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_10;
      }
    }
    jj_consume_token(STRUCT_END);
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTFunction functionStatementC(ASTNode parent) throws ParseException {
  String modifier;
  String returnType;
  Token name;
  String parameterType;
  Token parameterName;
  ASTStatement s;
  Token dimension;
    jj_consume_token(FUNCTION_DEC);
    name = jj_consume_token(IDENTIFIER);
    ASTFunctionC result = new ASTFunctionC(name.image);
    result.addParent(parent);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case CONST:
      case FINAL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case SYNCHRONIZED:
      case VOLATILE:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_11;
      }
      modifier = catchModifier();
      result.addModifier(modifier);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR:
    case DOUBLE:
    case FLOAT:
    case INT:
    case LONG:
    case SHORT:
    case STRUCT:
    case C_TYPES_MODIFIERS_SIGNED:
    case IDENTIFIER:
      returnType = types_C();
      result.addReturnType(new ASTExpressionUnitTypes(returnType));
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARAMETER:
      case PARAMETER_A:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARAMETER:
        jj_consume_token(PARAMETER);
        parameterType = types_C();
        parameterName = jj_consume_token(IDENTIFIER);
        ASTExpressionUnitTypes t = new ASTExpressionUnitTypes(parameterType);
        ASTExpressionUnitIdentifier i = new ASTExpressionUnitIdentifier(parameterName.image);
        result.addParameter(t, i);
        break;
      case PARAMETER_A:
        jj_consume_token(PARAMETER_A);
        jj_consume_token(DIMENSION);
        dimension = jj_consume_token(INTEGER_LITERAL);
        parameterType = types_C();
        jj_consume_token(ARRAY);
        parameterName = jj_consume_token(IDENTIFIER);
        ASTExpressionUnitTypesArray type = new ASTExpressionUnitTypesArray(parameterType, Integer.parseInt(dimension.image));
        ASTExpressionUnitIdentifier id = new ASTExpressionUnitIdentifier(parameterName.image);
        result.addParameter(type, id);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(FUNCTION_START);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case GOTO:
      case IF:
      case RETURN:
      case SWITCH:
      case WHILE:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case HOOK:
      case INCR:
      case DECR:
      case MINUS:
      case BIT_AND:
      case ASSIGNMENT:
      case CREATE:
      case VARIABLE:
      case VALUE:
      case FUNCTION:
      case POST:
      case ARRAY:
      case ACCESS:
      case LABEL:
      case INCLUDE:
      case FUNCTION_DEC:
      case STRUCT_DEC:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_13;
      }
      s = statementC(result);
      result.addStatement(s);
      //System.out.println(s.toSyntax());
    }
    jj_consume_token(FUNCTION_END);
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTIfStatementC if_statementC(ASTNode parent) throws ParseException {
  ASTExpression condition;
  ASTStatement stat1;
  ASTStatement stat2;
    jj_consume_token(IF);
    jj_consume_token(CONDITION);
    condition = expressionC();
    ASTIfStatementC result = new ASTIfStatementC(condition);
    result.addParent(parent);
    //System.out.println(condition.toSyntax());
    jj_consume_token(IF_BRANCH_START);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case GOTO:
      case IF:
      case RETURN:
      case SWITCH:
      case WHILE:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case HOOK:
      case INCR:
      case DECR:
      case MINUS:
      case BIT_AND:
      case ASSIGNMENT:
      case CREATE:
      case VARIABLE:
      case VALUE:
      case FUNCTION:
      case POST:
      case ARRAY:
      case ACCESS:
      case LABEL:
      case INCLUDE:
      case FUNCTION_DEC:
      case STRUCT_DEC:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_14;
      }
      stat1 = statementC(result);
      result.setIf(stat1);
      //System.out.println(stat1.toSyntax());
    }
    jj_consume_token(IF_BRANCH_END);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE_BRANCH_START:
      jj_consume_token(ELSE_BRANCH_START);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BREAK:
        case CONTINUE:
        case DO:
        case FOR:
        case GOTO:
        case IF:
        case RETURN:
        case SWITCH:
        case WHILE:
        case LPAREN:
        case LBRACE:
        case BANG:
        case TILDE:
        case HOOK:
        case INCR:
        case DECR:
        case MINUS:
        case BIT_AND:
        case ASSIGNMENT:
        case CREATE:
        case VARIABLE:
        case VALUE:
        case FUNCTION:
        case POST:
        case ARRAY:
        case ACCESS:
        case LABEL:
        case INCLUDE:
        case FUNCTION_DEC:
        case STRUCT_DEC:
          ;
          break;
        default:
          jj_la1[34] = jj_gen;
          break label_15;
        }
        stat2 = statementC(result);
        result.setElse(stat2);
        //System.out.println(stat2.toSyntax());
      }
      jj_consume_token(ELSE_BRANCH_END);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTForStatementC forStatementC(ASTNode parent) throws ParseException {
  ASTExpression init;
  ASTExpression end;
  ASTExpression increment;
  ASTStatement temp;
    jj_consume_token(FOR);
    ASTForStatementC result = new ASTForStatementC();
    result.addParent(parent);
    jj_consume_token(CONDITION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case MINUS:
    case BIT_AND:
    case ASSIGNMENT:
    case VARIABLE:
    case VALUE:
    case FUNCTION:
    case POST:
    case ARRAY:
    case ACCESS:
      init = expressionC();
      result.addInitial(init);
      //System.out.println(init.toSyntax());
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(CONDITION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case MINUS:
    case BIT_AND:
    case ASSIGNMENT:
    case VARIABLE:
    case VALUE:
    case FUNCTION:
    case POST:
    case ARRAY:
    case ACCESS:
      end = expressionC();
      result.addFinal(end);
      //System.out.println(end.toSyntax());
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    jj_consume_token(CONDITION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case MINUS:
    case BIT_AND:
    case ASSIGNMENT:
    case VARIABLE:
    case VALUE:
    case FUNCTION:
    case POST:
    case ARRAY:
    case ACCESS:
      increment = expressionC();
      result.addIncrement(increment);
      //System.out.println(increment.toSyntax());
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    jj_consume_token(FOR_START);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case GOTO:
      case IF:
      case RETURN:
      case SWITCH:
      case WHILE:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case HOOK:
      case INCR:
      case DECR:
      case MINUS:
      case BIT_AND:
      case ASSIGNMENT:
      case CREATE:
      case VARIABLE:
      case VALUE:
      case FUNCTION:
      case POST:
      case ARRAY:
      case ACCESS:
      case LABEL:
      case INCLUDE:
      case FUNCTION_DEC:
      case STRUCT_DEC:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_16;
      }
      temp = statementC(result);
      result.addStatement(temp);
      //System.out.println(temp.toSyntax());
    }
    jj_consume_token(FOR_END);
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTWhileStatementC whileStatementC(ASTNode parent) throws ParseException {
  ASTExpression exp;
  ASTStatement temp;
    jj_consume_token(WHILE);
    jj_consume_token(CONDITION);
    exp = expressionC();
    ASTWhileStatementC result = new ASTWhileStatementC(exp);
    result.addParent(parent);
    //System.out.println(exp.toSyntax());
    jj_consume_token(WHILE_START);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case GOTO:
      case IF:
      case RETURN:
      case SWITCH:
      case WHILE:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case HOOK:
      case INCR:
      case DECR:
      case MINUS:
      case BIT_AND:
      case ASSIGNMENT:
      case CREATE:
      case VARIABLE:
      case VALUE:
      case FUNCTION:
      case POST:
      case ARRAY:
      case ACCESS:
      case LABEL:
      case INCLUDE:
      case FUNCTION_DEC:
      case STRUCT_DEC:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_17;
      }
      temp = statementC(result);
      result.addStatement(temp);
      //System.out.println(temp.toSyntax());
    }
    jj_consume_token(WHILE_END);
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTDoWhileStatement doWhileStatement(ASTNode parent) throws ParseException {
  ASTExpression exp;
  ASTStatement temp;
    jj_consume_token(DO);
    jj_consume_token(CONDITION);
    exp = expressionC();
    ASTDoWhileStatement result = new ASTDoWhileStatement(exp);
    result.addParent(parent);
    //System.out.println(exp.toSyntax());
    jj_consume_token(WHILE_START);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case GOTO:
      case IF:
      case RETURN:
      case SWITCH:
      case WHILE:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case HOOK:
      case INCR:
      case DECR:
      case MINUS:
      case BIT_AND:
      case ASSIGNMENT:
      case CREATE:
      case VARIABLE:
      case VALUE:
      case FUNCTION:
      case POST:
      case ARRAY:
      case ACCESS:
      case LABEL:
      case INCLUDE:
      case FUNCTION_DEC:
      case STRUCT_DEC:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_18;
      }
      temp = statementC(result);
      result.addStatement(temp);
      //System.out.println(temp.toSyntax());
    }
    jj_consume_token(WHILE_END);
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTSwitchStatement switchStatement(ASTNode parent) throws ParseException {
  ASTExpression condition;
  ASTExpression case_condition;
  ASTStatement temp;
    jj_consume_token(SWITCH);
    jj_consume_token(CONDITION);
    condition = expressionC();
    ASTSwitchStatement result = new ASTSwitchStatement(condition);
    result.addParent(parent);
    //System.out.println(condition.toSyntax());
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
        ;
        break;
      default:
        jj_la1[42] = jj_gen;
        break label_19;
      }
      jj_consume_token(CASE);
      case_condition = expressionC();
      result.addCase(case_condition);
      //System.out.println(case_condition.toSyntax());
      jj_consume_token(CASE_START);
      label_20:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BREAK:
        case CONTINUE:
        case DO:
        case FOR:
        case GOTO:
        case IF:
        case RETURN:
        case SWITCH:
        case WHILE:
        case LPAREN:
        case LBRACE:
        case BANG:
        case TILDE:
        case HOOK:
        case INCR:
        case DECR:
        case MINUS:
        case BIT_AND:
        case ASSIGNMENT:
        case CREATE:
        case VARIABLE:
        case VALUE:
        case FUNCTION:
        case POST:
        case ARRAY:
        case ACCESS:
        case LABEL:
        case INCLUDE:
        case FUNCTION_DEC:
        case STRUCT_DEC:
          ;
          break;
        default:
          jj_la1[43] = jj_gen;
          break label_20;
        }
        temp = statementC(result);
        result.addStatement(temp);
        //System.out.println(temp.toSyntax());
      }
      jj_consume_token(CASE_END);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _DEFAULT:
      jj_consume_token(_DEFAULT);
      result.addDefault();
      jj_consume_token(CASE_START);
      label_21:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BREAK:
        case CONTINUE:
        case DO:
        case FOR:
        case GOTO:
        case IF:
        case RETURN:
        case SWITCH:
        case WHILE:
        case LPAREN:
        case LBRACE:
        case BANG:
        case TILDE:
        case HOOK:
        case INCR:
        case DECR:
        case MINUS:
        case BIT_AND:
        case ASSIGNMENT:
        case CREATE:
        case VARIABLE:
        case VALUE:
        case FUNCTION:
        case POST:
        case ARRAY:
        case ACCESS:
        case LABEL:
        case INCLUDE:
        case FUNCTION_DEC:
        case STRUCT_DEC:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_21;
        }
        temp = statementC(result);
        result.addStatement(temp);
        //System.out.println(temp.toSyntax());
      }
      jj_consume_token(CASE_END);
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

/*SimpleStatement*/
  static final public ASTBreakStatementC breakStatementC() throws ParseException {
  Token n;
    jj_consume_token(BREAK);
    ASTBreakStatementC result = new ASTBreakStatementC();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      n = jj_consume_token(IDENTIFIER);
      ASTExpressionUnitIdentifier label = new ASTExpressionUnitIdentifier(n.image);
      result.setLabel(label);
      break;
    default:
      jj_la1[46] = jj_gen;
      ;
    }
    jj_consume_token(TERMINATOR);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTContinueStatementC continueStatement() throws ParseException {
  Token n;
    jj_consume_token(CONTINUE);
    jj_consume_token(TERMINATOR);
    ASTContinueStatementC result = new ASTContinueStatementC();
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTReturnStatementC returnStatementC() throws ParseException {
  ASTExpression exp = null;
    jj_consume_token(RETURN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case MINUS:
    case BIT_AND:
    case ASSIGNMENT:
    case VARIABLE:
    case VALUE:
    case FUNCTION:
    case POST:
    case ARRAY:
    case ACCESS:
      exp = expressionC();
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
    jj_consume_token(TERMINATOR);
    ASTReturnStatementC result = new ASTReturnStatementC();
    if (exp != null)
    {
      result.addExp(exp);
    }
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTLabelStatement labelStatement() throws ParseException {
  Token n;
    jj_consume_token(LABEL);
    n = jj_consume_token(IDENTIFIER);
    jj_consume_token(TERMINATOR);
    ASTExpressionUnitIdentifier id = new ASTExpressionUnitIdentifier(n.image);
    ASTLabelStatement result = new ASTLabelStatement(id);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTImportStatementC importStatementC() throws ParseException {
  ASTExpression exp;
    jj_consume_token(INCLUDE);
    exp = expressionC();
    jj_consume_token(TERMINATOR);
    ASTImportStatementC result = new ASTImportStatementC(exp);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTGoToStatement gotoStatementC() throws ParseException {
  Token label;
    jj_consume_token(GOTO);
    label = jj_consume_token(IDENTIFIER);
    jj_consume_token(TERMINATOR);
    {if (true) return new ASTGoToStatement(new ASTExpressionUnitIdentifier(label.image));}
    throw new Error("Missing return statement in function");
  }

  static final public ASTSimpleStatement simpleStatementC() throws ParseException {
  ASTExpression result;
  ASTDeclarationStatementC out;
  ASTBreakStatementC bs;
  ASTContinueStatementC cs;
  ASTLabelStatement label;
  ASTReturnStatement rs;
  ASTImportStatementC is;
  ASTGoToStatement gt;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case MINUS:
    case BIT_AND:
    case ASSIGNMENT:
    case VARIABLE:
    case VALUE:
    case FUNCTION:
    case POST:
    case ARRAY:
    case ACCESS:
      result = expressionC();
      jj_consume_token(TERMINATOR);
    ASTExpressionStatementC output = new ASTExpressionStatementC(result);
    {if (true) return output;}
      break;
    case CREATE:
      out = create_variableC();
    {if (true) return out;}
      break;
    case BREAK:
      bs = breakStatementC();
    {if (true) return bs;}
      break;
    case CONTINUE:
      cs = continueStatement();
    {if (true) return cs;}
      break;
    case LABEL:
      label = labelStatement();
    {if (true) return label;}
      break;
    case RETURN:
      rs = returnStatementC();
    {if (true) return rs;}
      break;
    case INCLUDE:
      is = importStatementC();
    {if (true) return is;}
      break;
    case GOTO:
      gt = gotoStatementC();
    {if (true) return gt;}
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTBlockStatement blockStatementC(ASTNode parent) throws ParseException {
  ASTStructDeclaration structDeclare;
  ASTDoWhileStatement doWhile;
  ASTForStatement forStatement;
  ASTFunction functionDeclare;
  ASTIfStatement ifStatement;
  ASTWhileStatement whileStatement;
  ASTSwitchStatement switchStatement;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRUCT_DEC:
      structDeclare = structDeclareStatement(parent);
    {if (true) return structDeclare;}
      break;
    case DO:
      doWhile = doWhileStatement(parent);
    {if (true) return doWhile;}
      break;
    case FOR:
      forStatement = forStatementC(parent);
    {if (true) return forStatement;}
      break;
    case FUNCTION_DEC:
      functionDeclare = functionStatementC(parent);
    {if (true) return functionDeclare;}
      break;
    case IF:
      ifStatement = if_statementC(parent);
    {if (true) return ifStatement;}
      break;
    case WHILE:
      whileStatement = whileStatementC(parent);
    {if (true) return whileStatement;}
      break;
    case SWITCH:
      switchStatement = switchStatement(parent);
    {if (true) return switchStatement;}
      break;
    default:
      jj_la1[49] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement query() throws ParseException {
    jj_consume_token(HOOK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STRUCT:
      jj_consume_token(STRUCT);
      getStructure(current);
      {if (true) return new ASTStatement();}
      break;
    case TREE:
      jj_consume_token(TREE);
      getTree(current);
      {if (true) return new ASTStatement();}
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTStatement statementC(ASTNode parent) throws ParseException {
  ASTStatement result;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BREAK:
    case CONTINUE:
    case GOTO:
    case RETURN:
    case LPAREN:
    case LBRACE:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case MINUS:
    case BIT_AND:
    case ASSIGNMENT:
    case CREATE:
    case VARIABLE:
    case VALUE:
    case FUNCTION:
    case POST:
    case ARRAY:
    case ACCESS:
    case LABEL:
    case INCLUDE:
      result = simpleStatementC();
    current = result;
    result.addParent(parent);
    {if (true) return result;}
      break;
    case DO:
    case FOR:
    case IF:
    case SWITCH:
    case WHILE:
    case FUNCTION_DEC:
    case STRUCT_DEC:
      result = blockStatementC(parent);
    current = result;
    result.addParent(parent);
    {if (true) return result;}
      break;
    case HOOK:
      query();
    {if (true) return new ASTStatement();}
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public ASTCompilationUnitC programC() throws ParseException {
  Token name;
  ASTStatement statement;
    jj_consume_token(PROGRAM_C);
    name = jj_consume_token(IDENTIFIER);
    ASTCompilationUnitC result = new ASTCompilationUnitC(name.image);
    current = result;
    label_22:
    while (true) {
      statement = statementC(result);
      if (!statement.toSyntax().equals("\u005cn"))
      {
        //
        result.addStatement(statement);
        current = statement;
        //current.addStatement(statement);
		// important : Outputs to final program 
        System.out.println(statement.toSyntax());
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BREAK:
      case CONTINUE:
      case DO:
      case FOR:
      case GOTO:
      case IF:
      case RETURN:
      case SWITCH:
      case WHILE:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case HOOK:
      case INCR:
      case DECR:
      case MINUS:
      case BIT_AND:
      case ASSIGNMENT:
      case CREATE:
      case VARIABLE:
      case VALUE:
      case FUNCTION:
      case POST:
      case ARRAY:
      case ACCESS:
      case LABEL:
      case INCLUDE:
      case FUNCTION_DEC:
      case STRUCT_DEC:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_22;
      }
    }
    jj_consume_token(PROGRAM_END);
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static final public ASTCompilationUnit program() throws ParseException {
  ASTCompilationUnitC result;
    result = programC();
    current = result;
    //System.out.println(result.toSyntax());
    //System.out.println(result.toTree(0));
    //result.toFile();
    {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public ASTParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[53];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x10080000,0x0,0x4a00000,0x4000000,0x0,0x4000000,0x4000000,0x4a00000,0x10080000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10080000,0x4000000,0x0,0x0,0xa0400000,0xa0400000,0xa0400000,0x0,0x0,0x0,0x0,0xa0400000,0xa0400000,0xa0400000,0x1000000,0xa0400000,0xa0400000,0x40000000,0x0,0x0,0x20400000,0x80000000,0x0,0xa0400000,0xa0400000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x44e00020,0x10,0x4081,0x2014081,0x0,0x2014081,0x2014081,0x4081,0x44e00020,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x44e00020,0x2014081,0x0,0x0,0x21000700,0x21000700,0x21000700,0x0,0x0,0x0,0x0,0x21000700,0x21000700,0x21000700,0x0,0x21000700,0x21000700,0x0,0x0,0x0,0x1000200,0x20000500,0x0,0x21000700,0x21000700,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x60000000,0x0,0x80000000,0x0,0x40,0x61108,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x80280000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x280000,0x60000000,0x80000000,0x80280000,0x80280000,0x0,0x0,0x40,0x0,0x0,0x0,0x80280080,0x80280080,0x80280080,0x0,0x80280000,0x80280000,0x80280000,0x80280080,0x80280080,0x80280080,0x0,0x80280080,0x80280080,0x0,0x0,0x80280000,0x80280000,0x80,0x0,0x80280080,0x80280080,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x1807f9f8,0x7f80000,0x8601,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20009601,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1807f9f8,0x9601,0x9601,0x20009601,0x7f80000,0x40000000,0x0,0x0,0x0,0x0,0x60009603,0x60009603,0x60009603,0x0,0x20009601,0x20009601,0x20009601,0x60009603,0x60009603,0x60009603,0x0,0x60009603,0x60009603,0x0,0x0,0x20009601,0x60009601,0x0,0x0,0x60009603,0x60009603,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x4000,0x0,0x0,0x18807,0x80000,0x8001,0x8001,0x2000,0x2000,0x80000,0x0,0x18007,0x0,0x0,0x18807,0x18807,0x8,0x0,0x0,0x4000,0x2000,0x2000,0x40258807,0x40258807,0x40258807,0x100,0x18807,0x18807,0x18807,0x40258807,0x40258807,0x40258807,0x0,0x40258807,0x40258807,0x0,0x0,0x18807,0x258807,0x40000000,0x4000,0x40258807,0x40258807,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x0,0x400,0x1400,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1400,0x100,0x100,0x2,0x2,0x2,0x0,0x0,0x0,0x0,0x2,0x2,0x2,0x0,0x2,0x2,0x0,0x1000,0x0,0x0,0x2,0x200,0x2,0x2,};
   }

  /** Constructor with InputStream. */
  public ASTParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ASTParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ASTParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public ASTParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ASTParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ASTParser(ASTParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ASTParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[175];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 53; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 175; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
