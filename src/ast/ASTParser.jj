/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */options{  static = true;}PARSER_BEGIN(ASTParser)package ast;import java.util.*;/**
	@author GAO RISHENG A0101891L
	this class is in charge of translation between all structural command generated
	from the upper layer of this software to respective ASTNodes
	All the grammar rules are defined in this JavaCC class
	Currently only support C-language AST nodes translation
	Future development is to establish a full support to Java and Python
	line 59 - 319 are defined special tokens
	line 320 - 1464 are defined grammar rules for structural commands and how the compiler construct
	respective AST nodes in parsing respective structural commands 
*/public class ASTParser{  private static ASTNode current = new ASTNode();  private static ASTNode program = new ASTNode();  public static void main(String args []) throws ParseException  {    ASTParser parser = new ASTParser(System.in);    while (true)    {      System.out.println("Reading from standard input...");      System.out.print("Enter an program:\n");      try      {        program();        System.out.println("AST construction complete.");      }      catch (Exception e)      {        System.out.println("Not Supported Syntax Format");        System.out.println(e.getMessage());        ASTParser.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Unknown Error Occurs.");        System.out.println(e.getMessage());        break;      }    }  }  private static void getStructure(ASTNode current)  {    Stack < ASTNode > stack = new Stack < ASTNode > ();    ASTNode temp = current;    stack.push(temp);    while (temp.parent != null)    {      if (temp.isAblock())      {        stack.push(temp);      }      temp = temp.getParent();    }    int counter = 0;    while (!stack.isEmpty())    {      String indent = "";      for (int i = 0; i < counter; i++)      {        indent += "\t";      }      System.out.println(indent + stack.pop().typeof());    }  }}PARSER_END(ASTParser)/**********************************************
 * THE JAVACC TOKEN SPECIFICATION STARTS HERE *
 **********************************************//* JAVACC RESERVED WORDS: These are the only tokens in JavaCC but not in Java */< DEFAULT >TOKEN :{  < _LOOKAHEAD : "LOOKAHEAD" >| < _IGNORE_CASE : "IGNORE_CASE" >| < _PARSER_BEGIN : "PARSER_BEGIN" >| < _PARSER_END : "PARSER_END" >| < _JAVACODE : "JAVACODE" >| < _TOKEN : "TOKEN" >| < _SPECIAL_TOKEN : "SPECIAL_TOKEN" >| < _MORE : "MORE" >| < _SKIP : "SKIP" >| < _TOKEN_MGR_DECLS : "TOKEN_MGR_DECLS" >| < _EOF : "EOF" >}/*
 * The remainder of the tokens are exactly (except for the removal of tokens
 * containing ">>" and "<<") as in the Java grammar and must be diff equivalent
 * (again with the exceptions above) to it.
 *//* WHITE SPACE */< DEFAULT >SKIP :{  " "| "\t"| "\n"| "\r"| "\f"| "/*@egen*/" : AFTER_EGEN}< AFTER_EGEN >SKIP :{  < ~[ ] > : DEFAULT}/* JAVA RESERVED WORDS AND LITERALS */< DEFAULT >TOKEN :{  < ABSTRACT : "abstract" >| < ASSERT : "assert" >| < BOOLEAN : "boolean" >| < BREAK : "break" >| < BYTE : "byte" >| < CASE : "case" >| < CATCH : "catch" >| < CHAR : "char" >| < CLASS : "class" >| < CONST : "const" >| < CONTINUE : "continue" >| < _DEFAULT : "default" >| < DO : "do" >| < DOUBLE : "double" >| < ELSE : "else" >| < ENUM : "enum" >| < EXTENDS : "extends" >| < FALSE : "false" >| < FINAL : "final" >| < FINALLY : "finally" >| < FLOAT : "float" >| < FOR : "for" >| < GOTO : "goto" >| < IF : "if" >| < IMPLEMENTS : "implements" >| < IMPORT : "import" >| < INSTANCEOF : "instanceof" >| < INT : "int" >| < INTERFACE : "interface" >| < LONG : "long" >| < NATIVE : "native" >| < NEW : "new" >| < NULL : "null" >| < PACKAGE : "package" >| < PRIVATE : "private" >| < PROTECTED : "protected" >| < PUBLIC : "public" >| < RETURN : "return" >| < SHORT : "short" >| < STATIC : "static" >| < STRICTFP : "strictfp" >| < SUPER : "super" >| < SWITCH : "switch" >| < SYNCHRONIZED : "synchronized" >| < THIS : "this" >| < THROW : "throw" >| < THROWS : "throws" >| < TRANSIENT : "transient" >| < TRUE : "true" >| < TRY : "try" >| < VOID : "void" >| < VOLATILE : "volatile" >| < WHILE : "while" >}/* JAVA LITERALS */< DEFAULT >TOKEN :{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])? >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >| < FLOATING_POINT_LITERAL :    < DECIMAL_FLOATING_POINT_LITERAL >  | < HEXADECIMAL_FLOATING_POINT_LITERAL >>| < #DECIMAL_FLOATING_POINT_LITERAL :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | "." ([ "0"-"9" ])+ (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ < DECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ (< DECIMAL_EXPONENT >)? [ "f", "F", "d", "D" ] >| < #DECIMAL_EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < #HEXADECIMAL_FLOATING_POINT_LITERAL :    "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ (".")? < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])* "." ([ "0"-"9", "a"-"f", "A"-"F" ])+ < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])? >| < #HEXADECIMAL_EXPONENT : [ "p", "P" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >| < CHARACTER_LITERAL :    "\'"    (      ~[ "\'", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      )    )    "\'" >| < STRING_LITERAL :    "\""    (      ~[ "\"", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      | [ "0"-"7" ] ([ "0"-"7" ])?      | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]      )    )*    "\"" >}/* SEPARATORS */< DEFAULT >TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >}/* OPERATORS */< DEFAULT >TOKEN :{  < ASSIGN : "=" >| < LT : "<" >| < GT : ">" >| < BANG : "!" >| < TILDE : "~" >| < HOOK : "?" >| < COLON : ":" >| < EQ : "==" >| < LE : "<=" >| < GE : ">=" >| < NE : "!=" >| < SC_OR : "||" >| < SC_AND : "&&" >| < INCR : "++" >| < DECR : "--" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < BIT_AND : "&" >| < BIT_OR : "|" >| < XOR : "^" >| < REM : "%" >| < PLUSASSIGN : "+=" >| < MINUSASSIGN : "-=" >| < STARASSIGN : "*=" >| < SLASHASSIGN : "/=" >| < ANDASSIGN : "&=" >| < ORASSIGN : "|=" >| < XORASSIGN : "^=" >| < REMASSIGN : "%=" >| < SHIFT_LEFT : "<<" >| < SHIFT_RIGHT : " >>" >}/* keywords */TOKEN :{  < ASSIGNMENT : "#assign" >| < CREATE : "#create" >| < TYPE : "#type" >| < VARIABLE : "#variable" >| < VALUE : "#value" >| < FUNCTION : "#function" >| < WITH : "#with" >| < CONDITION : "#condition" >| < EXPRESSIONS : "#expression" >| < IF_BRANCH_START : "#if_branch_start" >| < IF_BRANCH_END : "#if_branch_end" >| < ELSE_BRANCH_START : "#else_branch_start" >| < ELSE_BRANCH_END : "#else_branch_end" >| < PRE : "#pre" >| < POST : "#post" >| < TERMINATOR : ";;" >| < PARAMETER : "#parameter" >| < STRUCT : "#struct" >| < ARRAY : "#array" >| < ACCESS : "#access" >| < ACCESS_END : "#access_end" >| < LABEL : "#label" >| < INDEX : "#indexes" >| < INDEX_END : "#index_end" >| < INCLUDE : "#include" >| < FOR_START : "#for_start" >| < FOR_END : "#for_end" >| < WHILE_START : "#while_start" >| < WHILE_END : "#while_end" >| < SWITCH_START : "#switch_start" >| < SWITCH_END : "#switch_end" >| < CASE_START : "#case_start" >| < CASE_END : "#case_end" >| < FUNCTION_DEC : "#function_declare" >| < FUNCTION_START : "#function_start" >| < FUNCTION_END : "#function_end" >| < STRUCT_DEC : "#struct_declare" >| < STRUCT_START : "#struct_start" >| < STRUCT_END : "#struct_end" >| < PROGRAM_END : "#program_end" >| < PROGRAM_C : "#c_program" >| < DECLARE_END : "#dec_end" >| < DIMENSION : "#dimension" >| < PARAMETER_A : "#parameter_a" >}TOKEN :{  < C_TYPES_MODIFIERS_SIGNED : "signed" >| < C_TYPES_MODIFIERS_UNSIGNED : "unsigned" >}/* IDENTIFIERS */TOKEN :{  < IDENTIFIER : < LETTER > (< PART_LETTER >)* >| < #LETTER : [ "$", "A"-"Z", "_", "a"-"z" ] >| < #PART_LETTER : [ "$", "0"-"9", "A"-"Z", "_", "a"-"z" ] >}String variable() :{  Token var;}{  < VARIABLE > var = < IDENTIFIER >  {    return var.image;  }}String infixOperators() :{  Token n;}{  n = < PLUS >  {    return n.image;  }| n = < MINUS >  {    return n.image;  }| n = < STAR >  {    return n.image;  }| n = < SLASH >  {    return n.image;  }| n = < LT >  {    return n.image;  }| n = < GT >  {    return n.image;  }| n = < EQ >  {    return n.image;  }| n = < LE >  {    return n.image;  }| n = < GE >  {    return n.image;  }| n = < NE >  {    return n.image;  }| n = < SC_OR >  {    return n.image;  }| n = < SC_AND >  {    return n.image;  }| n = < BIT_AND >  {    return n.image;  }| n = < BIT_OR >  {    return n.image;  }| n = < XOR >  {    return n.image;  }| n = < REM >  {    return n.image;  }| n = < SHIFT_LEFT >  {    return n.image;  }| n = < SHIFT_RIGHT >  {    return n.image;  }}String compoundOperators() :{  Token n;}{  n = < PLUSASSIGN >  {    return n.image;  }| n = < MINUSASSIGN >  {    return n.image;  }| n = < STARASSIGN >  {    return n.image;  }| n = < SLASHASSIGN >  {    return n.image;  }| n = < REMASSIGN >  {    return n.image;  }| n = < ORASSIGN >  {    return n.image;  }| n = < ANDASSIGN >  {    return n.image;  }| n = < XORASSIGN >  {    return n.image;  }}String prefixOperators() :{  Token n;}{  n = < INCR >  {    return n.image;  }| n = < DECR >  {    return n.image;  }| n = < BANG >  {    return n.image;  }| n = < TILDE >  {    return n.image;  }| n = < BIT_AND >  {    return n.image;  }}String postfixOperators() :{  Token n;}{  n = < INCR >  {    return n.image;  }| n = < DECR >  {    return n.image;  }}String catchModifier() :{  Token n;}{  n = < ABSTRACT >  {    return n.image;  }| n = < PRIVATE >  {    return n.image;  }| n = < PROTECTED >  {    return n.image;  }| n = < PUBLIC >  {    return n.image;  }| n = < STATIC >  {    return n.image;  }| n = < FINAL >  {    return n.image;  }| n = < SYNCHRONIZED >  {    return n.image;  }| n = < VOLATILE >  {    return n.image;  }| n = < CONST >  {    return n.image;  }}ASTExpressionUnitLiteral value() :{  Token n;  Token sign;  ASTExpressionUnitLiteral valueNode;}{  n = < INTEGER_LITERAL >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    //System.out.println(valueNode.print());
    return valueNode;  }| n = < FLOATING_POINT_LITERAL >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    //System.out.println(valueNode.print());
    return valueNode;  }| n = < CHARACTER_LITERAL >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    //System.out.println(valueNode.print());
    return valueNode;  }| n = < STRING_LITERAL >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    return valueNode;  }| n = < TRUE >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    return valueNode;  }| n = < FALSE >  {    valueNode = new ASTExpressionUnitLiteral(n.image);    return valueNode;  }}String primitive_typesJ() :{  Token n;}{  (    n = < BYTE >    {      return n.image;    }  | n = < INT >    {      return n.image;    }  | n = < CHAR >    {      return n.image;    }  | n = < DOUBLE >    {      return n.image;    }  | n = < FLOAT >    {      return n.image;    }  | n = < BOOLEAN >    {      return n.image;    }  )}String primitive_typesC() :{  Token n;  Token second;  Token third;}{  (    n = < INT >    {      return n.image;    }  | n = < CHAR >    {      return n.image;    }  | n = < LONG >    {      return n.image;    }  | n = < SHORT >    {      return n.image;    }  | n = < DOUBLE >    {      return n.image;    }  | n = < FLOAT >    {      return n.image;    }  | n = < C_TYPES_MODIFIERS_SIGNED >    {      return n.image;    }  )}String types_C() :{  String token;  String result = "";  Token n;}{  (< STRUCT >)? n = < IDENTIFIER >  {    return n.image;  }|  (    token = primitive_typesC()    {      result += token + " ";    }  )+  {    return result;  }}String typesJ() :{  String type;  Token n;}{  n = < IDENTIFIER >  {    return n.image;  }| type = primitive_typesJ()  {    return type;  }}ASTDeclarationStatementC create_variableC() :{  String type_token;  Token name;  String id;  ASTDeclarationStatementC result;  ASTExpressionUnitIdentifier var;  ASTExpression exp = new ASTExpression();  String temp;  ArrayList < String > modifiers = new ArrayList < String > ();}{  < CREATE >  (    temp = catchModifier()    {      modifiers.add(temp);    }  )*  type_token = types_C()  {    result = new ASTDeclarationStatementC(type_token);    for (String s : modifiers)    {      result.addModifier(s);    }  }  (    (      id = variable()      (        exp = expressionC()      )?      < DECLARE_END >      {        if (exp == null)        {          result.addVariableWithoutDeclaration(new ASTExpressionUnitIdentifier(id));        }        else        {          result.addVariableWithDeclaration(new ASTExpressionUnitIdentifier(id), exp);          exp = null;        }      }    )  |    (      < ARRAY > < VARIABLE > name = < IDENTIFIER >      {        ASTExpressionUnitIdentifierArrayObject array = new ASTExpressionUnitIdentifierArrayObject(name.image);      }      (        < INDEX > exp = expressionC() < INDEX_END >        {          array.addIndex(exp);          result.addVariableWithoutDeclaration(array);        }      )+      < DECLARE_END >    )  )+  < TERMINATOR >  {    return result;  }}ASTExpression fragmentC() :{  Token var = new Token();  String id;  Token check = new Token();  ASTExpressionUnitLiteral v = new ASTExpressionUnitLiteral();  ASTExpression parameters = new ASTExpression();  ASTExpression result = new ASTExpression();}{  (    < VALUE > v = value()  )  {    //System.out.println(v.toSyntax());
    return v;  }| id = variable()  {    return new ASTExpressionUnitIdentifier(id);  }|  (    < FUNCTION > var = < IDENTIFIER >    {      ASTExpressionUnitFunctionCall call = new ASTExpressionUnitFunctionCall(var.image);      //System.out.println(var.image);
    }    < LPAREN >    (      < PARAMETER > parameters = expressionC()      {        call.addParameter(parameters);      }    )*    < RPAREN >  )  {    return call;  }|  (    check = < LPAREN > result = expressionC() < RPAREN >  )  {    result.quote();    return result;  }| < LBRACE >  {    ASTExpressionUnitLiteralArray arr = new ASTExpressionUnitLiteralArray();  }  (    < PARAMETER > parameters = expressionC()  )*  {    arr.addValue(parameters);    return arr;  }  < RBRACE >| < ARRAY > var = < IDENTIFIER >  {    ASTExpressionUnitIdentifierArrayObject array = new ASTExpressionUnitIdentifierArrayObject(var.image);  }  (    < INDEX > parameters = expressionC() < INDEX_END >  )+  {    array.addIndex(parameters);    return array;  }| < ACCESS > (var = < IDENTIFIER >)  {    ArrayList < String > ids = new ArrayList < String > ();    ids.add(var.image);  }  (var = < IDENTIFIER >)+  {    ids.add(var.image);  }  < ACCESS_END >  {    return ASTExpressionUnitAccess.generateNestedAccess(ids);  }}ASTExpression termC() :{  ArrayList < String > operators = new ArrayList < String > ();  ArrayList < ASTExpression > operands = new ArrayList < ASTExpression > ();  String operator = null;  ASTExpression operand1;  ASTExpression operand2 = new ASTExpression();  ASTExpression result;}{  operand1 = fragmentC()  (    operator = infixOperators()    {      operators.add(operator);    }    operand2 = fragmentC()    {      operands.add(operand2);    }  )*  {    if (operator == null || operators.isEmpty())    {      result = operand1;      return result;    }    result = new ASTExpression();    while (!operators.isEmpty())    {      result = new ASTExpressionInfixOperation(operators.remove(0), operand1, operands.remove(0));      operand1 = result;    }    return result;  }}ASTExpression infix_expressionC() :{  ASTExpression result;}{  result = termC()  {    return result;  }}ASTExpression prefix_expressionC() :{  String operator;  Token op;  ASTExpressionUnitLiteral v;  ASTExpressionPrefixOperation result;  ASTExpression exp;}{  (    operator = prefixOperators() exp = fragmentC()  )  {    result = new ASTExpressionPrefixOperation(operator, exp);    return result;  }| op = < MINUS > exp = expressionC()  {    result = new ASTExpressionPrefixOperation(op.image, exp);  }}ASTExpression postfix_expressionC() :{  String operator;  Token var;}{  < POST > < VARIABLE > var = < IDENTIFIER > operator = postfixOperators()  {    ASTExpressionUnitIdentifier i = new ASTExpressionUnitIdentifier(var.image);    ASTExpressionPostfixOperation result = new ASTExpressionPostfixOperation(operator, i);    return result;  }}ASTExpression expressionC() :{  ASTExpression result1;  ASTExpression result2;  ASTExpression result3;  ASTExpression result4;}{  (    result1 = prefix_expressionC()    {      return result1;    }  | result2 = infix_expressionC()    {      return result2;    }  | result3 = postfix_expressionC()    {      return result3;    }  )| result4 = assignmentC()  {    return result4;  }}ASTExpression assignmentC() :{  ASTExpression term;  Token operator;  ASTExpression exp;  String op;}{  < ASSIGNMENT > term = fragmentC()  {}  (    token = < WITH >    {      op = " = ";    }  | op = compoundOperators()  )  exp = expressionC()  {    ASTExpressionAssignment result = new ASTExpressionAssignment(term, exp, op);    return result;  }}/*Block Statement*/ASTStructDeclaration structDeclareStatement() :{  Token name;  ASTDeclarationStatementC attribute;}{  < STRUCT_DEC > name = < IDENTIFIER >  {    ASTStructDeclaration result = new ASTStructDeclaration(name.image);  }  < STRUCT_START >  (    attribute = create_variableC()    {      result.addAttribute(attribute);      System.out.println(attribute.toSyntax());    }  )+  < STRUCT_END > < TERMINATOR >  {    return result;  }}ASTFunction functionStatementC() :{  String modifier;  String returnType;  Token name;  String parameterType;  Token parameterName;  ASTStatement s;  Token dimension;}{  < FUNCTION_DEC > name = < IDENTIFIER >  {    ASTFunctionC result = new ASTFunctionC(name.image);  }  (    modifier = catchModifier()    {      result.addModifier(modifier);    }  )*  (    returnType = types_C()    {      result.addReturnType(new ASTExpressionUnitTypes(returnType));    }  )?  (    (      < PARAMETER > parameterType = types_C() parameterName = < IDENTIFIER >      {        ASTExpressionUnitTypes t = new ASTExpressionUnitTypes(parameterType);        ASTExpressionUnitIdentifier i = new ASTExpressionUnitIdentifier(parameterName.image);        result.addParameter(t, i);      }    )  |    (      < PARAMETER_A > < DIMENSION > dimension = < INTEGER_LITERAL > parameterType = types_C() < ARRAY > parameterName = < IDENTIFIER >      {        ASTExpressionUnitTypesArray type = new ASTExpressionUnitTypesArray(parameterType, Integer.parseInt(dimension.image));        ASTExpressionUnitIdentifier id = new ASTExpressionUnitIdentifier(parameterName.image);        result.addParameter(type, id);      }    )  )*  < FUNCTION_START >  (    s = statementC()    {      result.addStatement(s);      System.out.println(s.toSyntax());    }  )*  < FUNCTION_END > < TERMINATOR >  {    return result;  }}ASTIfStatementC if_statementC() :{  ASTExpression condition;  ASTStatement stat1;  ASTStatement stat2;}{  < IF > < CONDITION > condition = expressionC()  {    ASTIfStatementC result = new ASTIfStatementC(condition);    System.out.println(condition.toSyntax());  }  < IF_BRANCH_START >  (    stat1 = statementC()    {      result.setIf(stat1);      System.out.println(stat1.toSyntax());    }  )*  < IF_BRANCH_END >  (    < ELSE_BRANCH_START >    (      stat2 = statementC()      {        result.setElse(stat2);        System.out.println(stat2.toSyntax());      }    )*    < ELSE_BRANCH_END >  )?  < TERMINATOR >  {    return result;  }}ASTForStatementC forStatementC() :{  ASTExpression init;  ASTExpression end;  ASTExpression increment;  ASTStatement temp;}{  < FOR >  {    ASTForStatementC result = new ASTForStatementC();  }  < CONDITION >  (    init = expressionC()    {      result.addInitial(init);      System.out.println(init.toSyntax());    }  )?  < CONDITION >  (    end = expressionC()    {      result.addFinal(end);      System.out.println(end.toSyntax());    }  )?  < CONDITION >  (    increment = expressionC()    {      result.addIncrement(increment);      System.out.println(increment.toSyntax());    }  )?  < FOR_START >  (    temp = statementC()    {      result.addStatement(temp);      System.out.println(temp.toSyntax());    }  )*  < FOR_END > < TERMINATOR >  {    return result;  }}ASTWhileStatementC whileStatementC() :{  ASTExpression exp;  ASTStatement temp;}{  < WHILE > < CONDITION > exp = expressionC()  {    ASTWhileStatementC result = new ASTWhileStatementC(exp);    System.out.println(exp.toSyntax());  }  < WHILE_START >  (    temp = statementC()    {      result.addStatement(temp);      System.out.println(temp.toSyntax());    }  )*  < WHILE_END > < TERMINATOR >  {    return result;  }}ASTDoWhileStatement doWhileStatement() :{  ASTExpression exp;  ASTStatement temp;}{  < DO > < CONDITION > exp = expressionC()  {    ASTDoWhileStatement result = new ASTDoWhileStatement(exp);    System.out.println(exp.toSyntax());  }  < WHILE_START >  (    temp = statementC()    {      result.addStatement(temp);      System.out.println(temp.toSyntax());    }  )*  < WHILE_END > < TERMINATOR >  {    return result;  }}ASTSwitchStatement switchStatement() :{  ASTExpression condition;  ASTExpression case_condition;  ASTStatement temp;}{  < SWITCH > < CONDITION > condition = expressionC()  {    ASTSwitchStatement result = new ASTSwitchStatement(condition);    System.out.println(condition.toSyntax());  }  (    < CASE > case_condition = expressionC()    {      result.addCase(case_condition);      System.out.println(case_condition.toSyntax());    }    < CASE_START >    (      temp = statementC()      {        result.addStatement(temp);        System.out.println(temp.toSyntax());      }    )*    < CASE_END >  )*  (    < _DEFAULT >    {      result.addDefault();    }    < CASE_START >    (      temp = statementC()      {        result.addStatement(temp);        System.out.println(temp.toSyntax());      }    )*    < CASE_END >  )?  < TERMINATOR >  {    return result;  }}/*SimpleStatement*/ASTBreakStatementC breakStatementC() :{  Token n;}{  < BREAK >  {    ASTBreakStatementC result = new ASTBreakStatementC();  }  (    n = < IDENTIFIER >    {      ASTExpressionUnitIdentifier label = new ASTExpressionUnitIdentifier(n.image);      result.setLabel(label);    }  )?  < TERMINATOR >  {    return result;  }}ASTContinueStatementC continueStatement() :{  Token n;}{  < CONTINUE > < TERMINATOR >  {    ASTContinueStatementC result = new ASTContinueStatementC();    return result;  }}ASTReturnStatementC returnStatementC() :{  ASTExpression exp = null;}{  < RETURN >  (    exp = expressionC()  )?  < TERMINATOR >  {    ASTReturnStatementC result = new ASTReturnStatementC();    if (exp != null)    {      result.addExp(exp);    }    return result;  }}ASTLabelStatement labelStatement() :{  Token n;}{  < LABEL > n = < IDENTIFIER > < TERMINATOR >  {    ASTExpressionUnitIdentifier id = new ASTExpressionUnitIdentifier(n.image);    ASTLabelStatement result = new ASTLabelStatement(id);    return result;  }}ASTImportStatementC importStatementC() :{  ASTExpression exp;}{  < INCLUDE > exp = expressionC() < TERMINATOR >  {    ASTImportStatementC result = new ASTImportStatementC(exp);    return result;  }}ASTGoToStatement gotoStatementC() :{  Token label;}{  < GOTO > label = < IDENTIFIER > < TERMINATOR >  {    return new ASTGoToStatement(new ASTExpressionUnitIdentifier(label.image));  }}ASTSimpleStatement simpleStatementC() :{  ASTExpression result;  ASTDeclarationStatementC out;  ASTBreakStatementC bs;  ASTContinueStatementC cs;  ASTLabelStatement label;  ASTReturnStatement rs;  ASTImportStatementC is;  ASTGoToStatement gt;}{  (    result = expressionC() < TERMINATOR >  )  {    ASTExpressionStatementC output = new ASTExpressionStatementC(result);    return output;  }| out = create_variableC()  {    return out;  }| bs = breakStatementC()  {    return bs;  }| cs = continueStatement()  {    return cs;  }| label = labelStatement()  {    return label;  }| rs = returnStatementC()  {    return rs;  }| is = importStatementC()  {    return is;  }| gt = gotoStatementC()  {    return gt;  }}ASTBlockStatement blockStatementC() :{  ASTStructDeclaration structDeclare;  ASTDoWhileStatement doWhile;  ASTForStatement forStatement;  ASTFunction functionDeclare;  ASTIfStatement ifStatement;  ASTWhileStatement whileStatement;  ASTSwitchStatement switchStatement;}{  structDeclare = structDeclareStatement()  {    return structDeclare;  }| doWhile = doWhileStatement()  {    return doWhile;  }| forStatement = forStatementC()  {    return forStatement;  }| functionDeclare = functionStatementC()  {    return functionDeclare;  }| ifStatement = if_statementC()  {    return ifStatement;  }| whileStatement = whileStatementC()  {    return whileStatement;  }| switchStatement = switchStatement()  {    return switchStatement;  }}ASTStatement query() :{}{  "?" < STRUCT >  {    getStructure(current);    return new ASTStatement();  }}ASTStatement statementC() :{  ASTStatement result;}{  result = simpleStatementC()  {
    current = result;    return result;  }| result = blockStatementC()  {
    current = result;    return result;  }| query()  {    return new ASTStatement();  }}ASTCompilationUnitC programC() :{  Token name;  ASTStatement statement;}{  < PROGRAM_C > name = < IDENTIFIER >  {    ASTCompilationUnitC result = new ASTCompilationUnitC(name.image);
    current = result;  }  (    statement = statementC()    {      if (!statement.toSyntax().equals("\n"))      {        //current = statement;        result.addStatement(statement);
        //current.addStatement(statement);        System.out.println(statement.toSyntax());      }    }  )+  < PROGRAM_END >  {    return result;  }}ASTCompilationUnit program() :{  ASTCompilationUnitC result;}{  result = programC()  {    current = result;    System.out.println(result.toSyntax());    //result.toFile();
    return result;  }}